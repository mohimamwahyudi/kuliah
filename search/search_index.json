{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"selamat datang di halaman tugas penambangan data \u00b6 profil \u00b6 `NAMA : MOH. IMAM WAHYUDI `NIM :180411100007 `KELAS :PENAMBANGAN DATA 5-D `JURUSAN : TEKNIK INFORMATIKA \u200b","title":"index"},{"location":"#selamat-datang-di-halaman-tugas-penambangan-data","text":"","title":"selamat datang di halaman tugas penambangan data"},{"location":"#profil","text":"`NAMA : MOH. IMAM WAHYUDI `NIM :180411100007 `KELAS :PENAMBANGAN DATA 5-D `JURUSAN : TEKNIK INFORMATIKA \u200b","title":"profil"},{"location":"MISSING VELUES/","text":"MISSING VELUES \u00b6 didalam menghitung mising velues dengan menggunakan metode K-NN disini kita harus menghitung jaraknya terlebih dahulu Menghitung jarak tipe numerik \u00b6 Salah satu tantangan dalam era ini dengan datatabase yang memiliki banyak tipe data. Mengukur jarak adalah komponen utama dalam algoritma clustering berbasis jarak. Alogritma seperit Algoritma Partisioning misal K-Mean, K-medoidm dan fuzzy c-mean dan rough clustering bergantung pada jarak untuk melakukan pengelompokkan Sebelum menjelaskan tentang beberapa macam ukuran jarak, kita mendefinisikan terlebih dahulu yaiut v1,v2 menyatakandua vektor yang menyatakan v1=x1,x2,...,xn,v2=y1,y2,...,yn, dimana xi,yi disebut attribut. Ada beberapa ukuran similaritas datau ukuran jarak, diantaranya Minkowski Distance $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$ Manhattan distance $$ d _ { \\operatorname { man } } = \\sum _ { i = 1 } ^ { n } \\left| x _ { i } - y _ { i } \\right| $$ Euclidean distance Average Distance $$ d _ { a v e } = \\left ( \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } ( x _ { i } - y _ { i } ) ^ { 2 } \\right) ^ { \\frac { 1 } { 2 } } $$ Weighted euclidean distance $$ d _ { w e } = \\left ( \\sum _ { i = 1 } ^ { n } w _ { i } ( x _ { i } - y _ { i } \\right) ^ { 2 } ) ^ { \\frac { 1 } { 2 } } $$ Chord distance $$ d _ { \\text {chord} } = \\left ( 2 - 2 \\frac { \\sum _ { i = 1 } ^ { n } x _ { i } y _ { i } } { | x | _ { 2 } | y | _ { 2 } } \\right) ^ { \\frac { 1 } { 2 } } $$ dimana $$ L^{2} \\text {-norm} | x | {2} = \\sqrt { \\sum { i = 1 }^{ n }x_{i}^{2}} $$ ##### Menghitung Jarak Ordinal Nilai-nilai atribut ordinal memiliki urutan atau peringkat, namun besarnya antara nilai-nilai berturut-turut tidak diketahui. Contohnya tingkatan kecil, sedang, besar untuk atribut ukuran. Atribut ordinal juga dapat diperoleh dari diskritisasi atribut numerik dengan membuat rentang nilai ke dalam sejumlah kategori tertentu. Kategori-kategori ini disusun dalam peringkat. Yaitu, rentang atribut numerik dapat dipetakan ke atribut ordinal ff yang memiliki MfMf state. Misalnya, kisaran suhu atribut skala-skala (dalam Celcius)dapat diatur ke dalam status berikut: \u221230 hingga \u221210, \u221210 hingga 10, 10 hingga 30, masing-masing mewakili kategori suhu dingin, suhu sedang, dan suhu hangat. MM adalah jumlah keadaan yang dapat dilakukan oleh atribut ordinalmemiliki. State ini menentukan peringkat 1,...,Mf rumus $$ z _ { i f } = \\frac { r _ { i f } - 1 } { M _ { f } - 1 } $$ berikut menghitung jarak dengan python ~~~py import pandas as pd import math as mt from sklearn.preprocessing import LabelEncoder data = pd.read_csv('jarak.csv', sep=';') df = pd.DataFrame(data) df.style.hide_index() ~~~ nama jesnis kelamin ipk p ortu prestasi imam l 3.8 3000000 internasional suci p 3.5 9000000 nasional rizky l 3.3 4000000 regional ```py X = data.iloc[:,:].values labelEncode_X = LabelEncoder() X[:,1] = labelEncode_X.fit_transform(X[:,1]) def Zscore(x,mean,std): top = x - mean if top==0: return top else: return round(top / std, 2) #menghitung jarak tipe numerikal def euclidianDistance(x,y): dis = 0 for i in range(len(x)): dis += (x[i] - y[i]) ** 2 return round(mt.sqrt(dis),2) def normalisasi(num, col_x): return Zscore(num, pd.Series(data[col_x].values).mean(), pd.Series(data[col_x].values).std()) #Menghitung Jarak tipe categorikal def distanceNom(x,y): p = len(x) or len(y) m = 0 for i in range(len(x)): if x[i][0] == y[i][0]: m +=1 return (p - m) / p #Menghitung Jarak tipe ordinal #inisialisasi x = {'Internasional':3,'Nasional':2,'Regional':1} def normalizedOrd(y): i_max = 0 for i in x: if x[i] > i_max: i_max = x[i] if y[0] == i: i_val = x[i] return (i_val - 1) / (i_max - 1) #Menghitung jarak tipe binary def distanceSimetris(x,y): q=r=s=t=0 for i in range(len(x)): if x[i]==1 and y[i]==1: q+=1 elif x[i]==1 and y[i]==0: r+=1 elif x[i]==0 and y[i]==1: s+=1 elif x[i]==0 and y[i]==0: t+=1 return ((r+s)/(q+r+s+t)) d_x = { 0 : ['', 'Ali', 'Ani', 'Abi'], 1 : ['Ali', 0, '', ''], 2 : ['Ani', '', 0, ''], 3 : ['Abi', '', '', 0] } #ambil data numerikal aliNum = df.iloc[0, 2:4].values aniNum = df.iloc[1, 2:4].values abiNum = df.iloc[2, 2:4].values #normalisasi data numerikal aliNum = [normalisasi(aliNum[0], data.columns[2]), normalisasi(aliNum[1], data.columns[3])] aniNum = [normalisasi(aniNum[0], data.columns[2]), normalisasi(aniNum[1], data.columns[3])] abiNum = [normalisasi(abiNum[0], data.columns[2]), normalisasi(abiNum[1], data.columns[3])] d_x[1][2] = euclidianDistance(aniNum,aliNum) d_x[1][3] = euclidianDistance(abiNum,aliNum) d_x[2][3] = euclidianDistance(abiNum,aniNum) d_x = pd.DataFrame(d_x) d_x.style.hide_index() ``` 0 1 2 3 imam suci rizky imam 0 suci 2.83 0 rizky 1.41 1.41 0 #ambil data binary imamBin = X [ 0 , 1 : 2 ] suciBin = X [ 1 , 1 : 2 ] rizkyBin = X [ 2 , 1 : 2 ] d_x [ 1 ][ 2 ] = distanceSimetris ( suciBin , imamBin ) d_x [ 1 ][ 3 ] = distanceSimetris ( rizkyBin , imamBin ) d_x [ 2 ][ 3 ] = distanceSimetris ( rizkyBin , suciBin ) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci rizky imam 0 suci 1 0 rizky 0 1 0 #ambil data ordinal aliOrd = [ df . iloc [ 0 , 5 : 6 ] . values ] aniOrd = [ df . iloc [ 1 , 5 : 6 ] . values ] abiOrd = [ df . iloc [ 2 , 5 : 6 ] . values ] d_x [ 1 ][ 2 ] = euclidianDistance ([ normalizedOrd ( aniOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 1 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 2 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aniOrd )]) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci rizky imam 0 suci 1 0 rizky 0.5 0.5 0 #ambil data ordinal aliOrd = [ df . iloc [ 0 , 5 : 6 ] . values ] aniOrd = [ df . iloc [ 1 , 5 : 6 ] . values ] abiOrd = [ df . iloc [ 2 , 5 : 6 ] . values ] d_x [ 1 ][ 2 ] = euclidianDistance ([ normalizedOrd ( aniOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 1 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 2 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aniOrd )]) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci imam imam 0 suci 5.83 0 rizky 2.91 3.91 0 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"mising velues"},{"location":"MISSING VELUES/#missing-velues","text":"didalam menghitung mising velues dengan menggunakan metode K-NN disini kita harus menghitung jaraknya terlebih dahulu","title":"MISSING VELUES"},{"location":"MISSING VELUES/#menghitung-jarak-tipe-numerik","text":"Salah satu tantangan dalam era ini dengan datatabase yang memiliki banyak tipe data. Mengukur jarak adalah komponen utama dalam algoritma clustering berbasis jarak. Alogritma seperit Algoritma Partisioning misal K-Mean, K-medoidm dan fuzzy c-mean dan rough clustering bergantung pada jarak untuk melakukan pengelompokkan Sebelum menjelaskan tentang beberapa macam ukuran jarak, kita mendefinisikan terlebih dahulu yaiut v1,v2 menyatakandua vektor yang menyatakan v1=x1,x2,...,xn,v2=y1,y2,...,yn, dimana xi,yi disebut attribut. Ada beberapa ukuran similaritas datau ukuran jarak, diantaranya Minkowski Distance $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$ Manhattan distance $$ d _ { \\operatorname { man } } = \\sum _ { i = 1 } ^ { n } \\left| x _ { i } - y _ { i } \\right| $$ Euclidean distance Average Distance $$ d _ { a v e } = \\left ( \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } ( x _ { i } - y _ { i } ) ^ { 2 } \\right) ^ { \\frac { 1 } { 2 } } $$ Weighted euclidean distance $$ d _ { w e } = \\left ( \\sum _ { i = 1 } ^ { n } w _ { i } ( x _ { i } - y _ { i } \\right) ^ { 2 } ) ^ { \\frac { 1 } { 2 } } $$ Chord distance $$ d _ { \\text {chord} } = \\left ( 2 - 2 \\frac { \\sum _ { i = 1 } ^ { n } x _ { i } y _ { i } } { | x | _ { 2 } | y | _ { 2 } } \\right) ^ { \\frac { 1 } { 2 } } $$ dimana $$ L^{2} \\text {-norm} | x | {2} = \\sqrt { \\sum { i = 1 }^{ n }x_{i}^{2}} $$ ##### Menghitung Jarak Ordinal Nilai-nilai atribut ordinal memiliki urutan atau peringkat, namun besarnya antara nilai-nilai berturut-turut tidak diketahui. Contohnya tingkatan kecil, sedang, besar untuk atribut ukuran. Atribut ordinal juga dapat diperoleh dari diskritisasi atribut numerik dengan membuat rentang nilai ke dalam sejumlah kategori tertentu. Kategori-kategori ini disusun dalam peringkat. Yaitu, rentang atribut numerik dapat dipetakan ke atribut ordinal ff yang memiliki MfMf state. Misalnya, kisaran suhu atribut skala-skala (dalam Celcius)dapat diatur ke dalam status berikut: \u221230 hingga \u221210, \u221210 hingga 10, 10 hingga 30, masing-masing mewakili kategori suhu dingin, suhu sedang, dan suhu hangat. MM adalah jumlah keadaan yang dapat dilakukan oleh atribut ordinalmemiliki. State ini menentukan peringkat 1,...,Mf rumus $$ z _ { i f } = \\frac { r _ { i f } - 1 } { M _ { f } - 1 } $$ berikut menghitung jarak dengan python ~~~py import pandas as pd import math as mt from sklearn.preprocessing import LabelEncoder data = pd.read_csv('jarak.csv', sep=';') df = pd.DataFrame(data) df.style.hide_index() ~~~ nama jesnis kelamin ipk p ortu prestasi imam l 3.8 3000000 internasional suci p 3.5 9000000 nasional rizky l 3.3 4000000 regional ```py X = data.iloc[:,:].values labelEncode_X = LabelEncoder() X[:,1] = labelEncode_X.fit_transform(X[:,1]) def Zscore(x,mean,std): top = x - mean if top==0: return top else: return round(top / std, 2) #menghitung jarak tipe numerikal def euclidianDistance(x,y): dis = 0 for i in range(len(x)): dis += (x[i] - y[i]) ** 2 return round(mt.sqrt(dis),2) def normalisasi(num, col_x): return Zscore(num, pd.Series(data[col_x].values).mean(), pd.Series(data[col_x].values).std()) #Menghitung Jarak tipe categorikal def distanceNom(x,y): p = len(x) or len(y) m = 0 for i in range(len(x)): if x[i][0] == y[i][0]: m +=1 return (p - m) / p #Menghitung Jarak tipe ordinal #inisialisasi x = {'Internasional':3,'Nasional':2,'Regional':1} def normalizedOrd(y): i_max = 0 for i in x: if x[i] > i_max: i_max = x[i] if y[0] == i: i_val = x[i] return (i_val - 1) / (i_max - 1) #Menghitung jarak tipe binary def distanceSimetris(x,y): q=r=s=t=0 for i in range(len(x)): if x[i]==1 and y[i]==1: q+=1 elif x[i]==1 and y[i]==0: r+=1 elif x[i]==0 and y[i]==1: s+=1 elif x[i]==0 and y[i]==0: t+=1 return ((r+s)/(q+r+s+t)) d_x = { 0 : ['', 'Ali', 'Ani', 'Abi'], 1 : ['Ali', 0, '', ''], 2 : ['Ani', '', 0, ''], 3 : ['Abi', '', '', 0] } #ambil data numerikal aliNum = df.iloc[0, 2:4].values aniNum = df.iloc[1, 2:4].values abiNum = df.iloc[2, 2:4].values #normalisasi data numerikal aliNum = [normalisasi(aliNum[0], data.columns[2]), normalisasi(aliNum[1], data.columns[3])] aniNum = [normalisasi(aniNum[0], data.columns[2]), normalisasi(aniNum[1], data.columns[3])] abiNum = [normalisasi(abiNum[0], data.columns[2]), normalisasi(abiNum[1], data.columns[3])] d_x[1][2] = euclidianDistance(aniNum,aliNum) d_x[1][3] = euclidianDistance(abiNum,aliNum) d_x[2][3] = euclidianDistance(abiNum,aniNum) d_x = pd.DataFrame(d_x) d_x.style.hide_index() ``` 0 1 2 3 imam suci rizky imam 0 suci 2.83 0 rizky 1.41 1.41 0 #ambil data binary imamBin = X [ 0 , 1 : 2 ] suciBin = X [ 1 , 1 : 2 ] rizkyBin = X [ 2 , 1 : 2 ] d_x [ 1 ][ 2 ] = distanceSimetris ( suciBin , imamBin ) d_x [ 1 ][ 3 ] = distanceSimetris ( rizkyBin , imamBin ) d_x [ 2 ][ 3 ] = distanceSimetris ( rizkyBin , suciBin ) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci rizky imam 0 suci 1 0 rizky 0 1 0 #ambil data ordinal aliOrd = [ df . iloc [ 0 , 5 : 6 ] . values ] aniOrd = [ df . iloc [ 1 , 5 : 6 ] . values ] abiOrd = [ df . iloc [ 2 , 5 : 6 ] . values ] d_x [ 1 ][ 2 ] = euclidianDistance ([ normalizedOrd ( aniOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 1 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 2 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aniOrd )]) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci rizky imam 0 suci 1 0 rizky 0.5 0.5 0 #ambil data ordinal aliOrd = [ df . iloc [ 0 , 5 : 6 ] . values ] aniOrd = [ df . iloc [ 1 , 5 : 6 ] . values ] abiOrd = [ df . iloc [ 2 , 5 : 6 ] . values ] d_x [ 1 ][ 2 ] = euclidianDistance ([ normalizedOrd ( aniOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 1 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aliOrd )]) d_x [ 2 ][ 3 ] = euclidianDistance ([ normalizedOrd ( abiOrd )],[ normalizedOrd ( aniOrd )]) d_x = pd . DataFrame ( d_x ) d_x . style . hide_index () 0 1 2 3 imam suci imam imam 0 suci 5.83 0 rizky 2.91 3.91 0 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Menghitung jarak tipe numerik"},{"location":"pengertian/","text":"STATISTIK DESKRIPTIF \u00b6 pengertian \u00b6 PENGERTIAN STATISTIK DEKRIPTIF ADALAH metode pengumpulan sebuah data data yang akan menghasilkan informasi yang berguna TIPE STATISTIK DESKRIPTIF \u00b6 MEAN(RATA-RATA) \u00b6 mean atau rata rata adalah sebuah nilai yang jumlah dari seluruah angka atau data dan di bagi banyak data . misal memiliki N data bisa di hitung dengan rumus sebagai berikut $$ \\begin{align} \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i={a_1+a_2+a_3+a_4+........+a_n \\over n} \\end{align} $$ keterangan: x=rata-rata a=nilai ke N n=banyak nilai atau data MEDIAN \u00b6 median merupakan nilai tengah dalam suatu data median disimbolkan Me .menghitung median mempunyai 2 metode yaitu ketika N atau jumlah data ganjil atau genap. berikut rumus median ; $$ Me=Q_2 =\\left( \\begin{matrix} n+1 \\over 2 \\end{matrix} \\right), jika\\quad n\\quad ganjil $$ $$ Me=Q_2 =\\left( \\begin{matrix} {xn \\over 2 } {xn+1\\over 2} \\over 2 \\end{matrix} \\right), jika\\quad n\\quad genap $$ ket: me =median atau nilai tengah n=banyak data MODUS \u00b6 MODUS ADALAH nilai yang sering muncul dalam himpunan data.brikut ini rumus mencari modus dalam himpunan data $$ M_o = Tb + p{b_1 \\over b_1 + b_2} $$ ket; mo=nilai modus tb= tepi bawah b1=selisih frekuensi antara nilai mudus dengan elemen sebelumnya b2=selisih frekuensi antara nilai mudus dengan elemen sesudahnya p= panjang interval varian \u00b6 varian adalah penyebaran nilai dalam suatu data dari rata rata .berikut ini rumus dari varian dalam himpunan data $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$ ket: x=rata rata Xi=rata rata dari semua titik data n= banyak dari anggota data standart deviasi \u00b6 Standar deviasi adalah ukuran dispersi himpunan data relatif pada rata-rata atau bisa juga akar kuadrat positif dari varian. berikut ini rumus standat deviasi: $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$ skewness( kemiringan ) \u00b6 skewness( kemiringan ) adalah suatu bentuk derajat ketidaksimestrian suatu data.skewness juga di sebut angka atau bilang yang dapat menunjukan ketidakmiringan atau kemiringan suatu data. berikut rumus skewness $$ Skewness = {\\sum \\limits{i=1}^n (x_i - \\bar x)^i \\over (n- 1) \\sigma^3} $$ ket: Xi=titik data x=rata-rata n=jumlah titik distribusi o=standar deviasi QUARTILE \u00b6 quartile merupakan bagian nilai yang di bagi 4 sama rata atau di bagi 25% berikut rumus dari quartile $$ Q_1 = (n + 1) {1\\over 4} $$ $$ Q_2 = (n + 1) {1\\over 2} $$ $$ Q_3 = (n + 1) {3\\over 4} $$ ket: q=nilai quarter n = banyak dari data Berikut penerapan statistik deskriptif di pyton \u00b6 sebelum itu buat data random melalui exsel lalu kita import file tadi seperti di bawah berikut import pandas as pd from scipy import stats df = pd . read_csv ( 'imam.csv' , sep = ';' ) data = { \"stats\" :[ 'Min' , 'Max' , 'Mean' , 'Standart Deviasi' , 'Variasi' , 'Skewnes' , 'Quantile 1' , 'Quantile 2' , 'Quantile 3' , 'Median' , 'Modus' ]} for i in df . columns : data [ i ] = [ df [ i ] . min (), df [ i ] . max (), df [ i ] . mean (), round ( df [ i ] . std (), 2 ), round ( df [ i ] . var (), 2 ), round ( df [ i ] . skew (), 2 ), df [ i ] . quantile ( 0.25 ), df [ i ] . quantile ( 0.5 ), df [ i ] . quantile ( 0.75 ), df [ i ] . median (), stats . mode ( df [ i ]) . mode [ 0 ]] tes = pd . DataFrame ( data ) tes . style . hide_index () berikut hasil setelah di jalankan stats ukuran baju ukuran sepatu ukaran celana umur Min 18 27 22 20 Max 30 42 36 40 Mean 23.76 34.452 28.812 29.828 Standart Deviasi 3.75 4.64 4.23 6.18 Variasi 14.05 21.53 17.93 38.18 Skewnes 0.08 0.02 0.08 -0 Quantile 1 21 30.75 25 24 Quantile 2 24 34 29 30 Quantile 3 27 39 32 35 Median 24 34 29 30 Modus 21 32 26 24 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"statistik deskriptif"},{"location":"pengertian/#statistik-deskriptif","text":"","title":"STATISTIK DESKRIPTIF"},{"location":"pengertian/#pengertian","text":"PENGERTIAN STATISTIK DEKRIPTIF ADALAH metode pengumpulan sebuah data data yang akan menghasilkan informasi yang berguna","title":"pengertian"},{"location":"pengertian/#tipe-statistik-deskriptif","text":"","title":"TIPE STATISTIK DESKRIPTIF"},{"location":"pengertian/#meanrata-rata","text":"mean atau rata rata adalah sebuah nilai yang jumlah dari seluruah angka atau data dan di bagi banyak data . misal memiliki N data bisa di hitung dengan rumus sebagai berikut $$ \\begin{align} \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i={a_1+a_2+a_3+a_4+........+a_n \\over n} \\end{align} $$ keterangan: x=rata-rata a=nilai ke N n=banyak nilai atau data","title":"MEAN(RATA-RATA)"},{"location":"pengertian/#median","text":"median merupakan nilai tengah dalam suatu data median disimbolkan Me .menghitung median mempunyai 2 metode yaitu ketika N atau jumlah data ganjil atau genap. berikut rumus median ; $$ Me=Q_2 =\\left( \\begin{matrix} n+1 \\over 2 \\end{matrix} \\right), jika\\quad n\\quad ganjil $$ $$ Me=Q_2 =\\left( \\begin{matrix} {xn \\over 2 } {xn+1\\over 2} \\over 2 \\end{matrix} \\right), jika\\quad n\\quad genap $$ ket: me =median atau nilai tengah n=banyak data","title":"MEDIAN"},{"location":"pengertian/#modus","text":"MODUS ADALAH nilai yang sering muncul dalam himpunan data.brikut ini rumus mencari modus dalam himpunan data $$ M_o = Tb + p{b_1 \\over b_1 + b_2} $$ ket; mo=nilai modus tb= tepi bawah b1=selisih frekuensi antara nilai mudus dengan elemen sebelumnya b2=selisih frekuensi antara nilai mudus dengan elemen sesudahnya p= panjang interval","title":"MODUS"},{"location":"pengertian/#varian","text":"varian adalah penyebaran nilai dalam suatu data dari rata rata .berikut ini rumus dari varian dalam himpunan data $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$ ket: x=rata rata Xi=rata rata dari semua titik data n= banyak dari anggota data","title":"varian"},{"location":"pengertian/#standart-deviasi","text":"Standar deviasi adalah ukuran dispersi himpunan data relatif pada rata-rata atau bisa juga akar kuadrat positif dari varian. berikut ini rumus standat deviasi: $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$","title":"standart deviasi"},{"location":"pengertian/#skewnesskemiringan","text":"skewness( kemiringan ) adalah suatu bentuk derajat ketidaksimestrian suatu data.skewness juga di sebut angka atau bilang yang dapat menunjukan ketidakmiringan atau kemiringan suatu data. berikut rumus skewness $$ Skewness = {\\sum \\limits{i=1}^n (x_i - \\bar x)^i \\over (n- 1) \\sigma^3} $$ ket: Xi=titik data x=rata-rata n=jumlah titik distribusi o=standar deviasi","title":"skewness(kemiringan)"},{"location":"pengertian/#quartile","text":"quartile merupakan bagian nilai yang di bagi 4 sama rata atau di bagi 25% berikut rumus dari quartile $$ Q_1 = (n + 1) {1\\over 4} $$ $$ Q_2 = (n + 1) {1\\over 2} $$ $$ Q_3 = (n + 1) {3\\over 4} $$ ket: q=nilai quarter n = banyak dari data","title":"QUARTILE"},{"location":"pengertian/#berikut-penerapan-statistik-deskriptif-di-pyton","text":"sebelum itu buat data random melalui exsel lalu kita import file tadi seperti di bawah berikut import pandas as pd from scipy import stats df = pd . read_csv ( 'imam.csv' , sep = ';' ) data = { \"stats\" :[ 'Min' , 'Max' , 'Mean' , 'Standart Deviasi' , 'Variasi' , 'Skewnes' , 'Quantile 1' , 'Quantile 2' , 'Quantile 3' , 'Median' , 'Modus' ]} for i in df . columns : data [ i ] = [ df [ i ] . min (), df [ i ] . max (), df [ i ] . mean (), round ( df [ i ] . std (), 2 ), round ( df [ i ] . var (), 2 ), round ( df [ i ] . skew (), 2 ), df [ i ] . quantile ( 0.25 ), df [ i ] . quantile ( 0.5 ), df [ i ] . quantile ( 0.75 ), df [ i ] . median (), stats . mode ( df [ i ]) . mode [ 0 ]] tes = pd . DataFrame ( data ) tes . style . hide_index () berikut hasil setelah di jalankan stats ukuran baju ukuran sepatu ukaran celana umur Min 18 27 22 20 Max 30 42 36 40 Mean 23.76 34.452 28.812 29.828 Standart Deviasi 3.75 4.64 4.23 6.18 Variasi 14.05 21.53 17.93 38.18 Skewnes 0.08 0.02 0.08 -0 Quantile 1 21 30.75 25 24 Quantile 2 24 34 29 30 Quantile 3 27 39 32 35 Median 24 34 29 30 Modus 21 32 26 24 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Berikut penerapan statistik  deskriptif  di pyton"}]}